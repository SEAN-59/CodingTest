# 정렬 알고리즘
- 내장 함수 : sorted()
    ```swift
    [2,1,5,7,9,6,3,11].sorted()
    
    // [1, 2, 3, 5, 6, 7, 9, 11]
    ```


## 1. 버블 정렬
[설명]
- 인접한 두 개의 원소를 비교 후 필요에 따라 위치를 교환하면서 정렬하는 알고리즘

[시간복잡도]
- 최선: O(n^2)
- 평균: O(n^2)
- 최악: O(n^2)

[평가]
- 큰 크기의 배열에서는 다소 비효율적일 수 있다.

### 동작 방식 (오름차순 시)
1. index 0 의 원소부터 인접한 원소(index.1)와 비교
2. 원하는 순서 확인 후 맞지 않다면 (1 > 0) 위치 교환
3. 끝까지 위의 과정을 반복하면 가장 큰 원소가 배열의 끝에 위치
4. 배열의 크기만큼 반복

- 예시 코드
    ```swift
    func bubbleSort(_ array: [Int]) -> [Int]{
        var result = array
        for i in 0 ..< result.count {
            for j in 0 ..< result.count - i - 1 {
                if result[j] > result[j+1] {
                    let big = result[j]
                    result[j] = result[j+1]
                    result[j+1] = big
                }
            }
        }
        return result
    }

    bubbleSort([2,1,5,7,9,6,3,11])

    // [1, 2, 3, 5, 6, 7, 9, 11]
    ```

## 2. 선택 정렬
[설명]
- 주어진 배열에서 최솟값을 선택해 정렬된 부분과 교환하는 과정을 반복해 정렬하는 알고리즘

[시간복잡도]
- 최선: O(n^2)
- 평균: O(n^2)
- 최악: O(n^2)

[평가]
- 비교 연산 횟수가 상수이기에 입력에 민감하지 않은 특징

### 동작 방식 (오름차순 시)
1. 주어진 배열에서 가장 작은 원소 검색
2. 해당 원소를 배열의 맨 앞 원소와 교환
3. 정렬된 부분이 하나씩 늘어나며 위의 과정을 반복해 정렬
- 예시 코드
    ```swift
    func selectionSort(_ array: [Int]) -> [Int]{
        var result = array
        for i in 0 ..< result.count {
            var minValue: Int = i
            for j in i ..< result.count {
                if result[minValue] > result[j] {
                    minValue = j
                }
            }
            let temp = result[i]
            result[i] = result[minValue]
            result[minValue] = temp
        }
        return result
    }

    selectionSort([2,1,5,7,9,6,3,11])

    // [1, 2, 3, 5, 6, 7, 9, 11]
    ```

## 3. 삽입 정렬
[설명]
- 배열의 요소를 하나씩 선택해 이미 정렬된 부분의 올바른 위치에 삽입하는 방식으로 정렬하는 알고리즘

[시간복잡도]
- 최선: O(n)
- 평균: O(n^2)
- 최악: O(n^2)

[평가]
- 작은 규모의 배열에 대해 효율적인 알고리즘

### 동작 방식 (오름차순 시)
1. index.1 의 원소부터 시작, index.0 과 비교
2. 맞지 않는다면 적절한 위치에 삽입
3. 다른 원소들을 우측 이동
4. index.0 까지 반복을 하여 정렬 완료
- 예시 코드
    ```swift
    func insertionSort(_ array: [Int]) -> [Int]{
        var result = array
        for i in 1 ..< result.count {
            var j = i
            while j > 0, result[j] < result[j-1] {
                result.swapAt(j, j-1)
                j -= 1
            }
        }
        return result
    }

    print(insertionSort([2,1,5,7,9,6,3,11])

    // [1, 2, 3, 5, 6, 7, 9, 11]
    ```

## 4. 퀵 정렬
[설명]
- 배열을 분할하고 재귀적으로 정렬하는 방식으로 동작하는 알고리즘
- 특정한 원소를 기준으로 배열을 분리한다.

[시간복잡도]
- 최선: O(nlogn)
- 평균: O(nlogn)
- 최악: O(n^2)

[평가]
- 평균적으로 가장 빠른 정렬 알고리즘 중 하나

### 동작 방식 (오름차순 시)
1. 배열에서 특정한 원소(pivot)를 선택 (보통 배열의 중간 원소를 선택)
2. pivot을 기준으로 작은 원소는 왼쪽 큰 원소는 오른쪽에 위치하도록 분할
3. 분할된 부분 배열에 대해서 퀵 정렬 수행
4. 분할된 부분 배열의 크기가 1이하가 될 때까지 반복
- 예시코드
    ```swift
    ```

## 5. 병합 정렬
[설명]
- 배열을 반으로 분할하고, 분할된 배열을 정렬한 뒤 병합해 최종적으로 정렬된 배열을 얻는 알고리즘

[시간복잡도]
- 최선: O(nlogn)
- 평균: O(nlogn)
- 최악: O(nlogn)
- 배열을 반으로 분할하는 단계가 O(nlogn)이고 분할된 배열을 병합하는 단계가 O(n)의 시간이 소요

[평가]
- 빠름

### 동작 방식 (오름차순 시)
- 예시코드
    ```swift
    ```


## 6. 힙 정렬
[설명]
- 힙 자료구조를 사용해 배열을 정렬하는 알고리즘
- 힙은 완전 이진트리의 일종으로, 최대 힙 또는 최소 힘의 조건을 만족
- 최대/최소 원소를 반복적으로 교환하여 정렬을 수행


[시간복잡도]
- 최선: O(nlogn)
- 평균: O(nlogn)
- 최악: O(nlogn)
- 배열을 힙으로 구성하는 과정에서 O(n)의 시간이 소요되고, 힙을 정렬 하는 과정에서 O(nlogn)의 시간이 소요

[평가]
- 빠름

### 동작 방식 (오름차순 시)
1. 주어진 배열을 힙으로 구성
2. 최대 힙인 경우, 힙의 최대 원소를 배열의 가장 마지막 원소와 교환
3. 교환된 원소는 정렬된 부분으로 간주하고, 힙의 크기를 줄여 재구성
4. 반복해 전체 배열 정렬

- 예시코드
    ```swift
    ```